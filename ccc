#!/usr/bin/env bash
set -euo pipefail

# =============================================================================
# ccc - Claude Code Container CLI
# =============================================================================

# Constants
readonly IMAGE_NAME_BASE="claude-code-sandbox:latest"
readonly LABEL_PREFIX="ccc"
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Image name (set after runtime detection - podman uses localhost/ prefix)
IMAGE_NAME=""

# Globals
QUIET=false
CONTAINER_RUNTIME=""  # Will be set by detect_runtime()
RUNTIME_MODE=""       # "podman", "docker-rootful", "docker-rootless"
BACKEND_OVERRIDE=""   # Set by -b/--backend flag

# =============================================================================
# Configuration
# =============================================================================

# Get config file path
get_config_file() {
    local config_dir="${XDG_CONFIG_HOME:-$HOME/.config}/ccc"
    echo "$config_dir/config.yaml"
}

# Load config value (simple grep-based YAML parsing)
load_config_value() {
    local key="$1"
    local config_file
    config_file=$(get_config_file)

    [[ ! -f "$config_file" ]] && return 1

    grep "^${key}:" "$config_file" 2>/dev/null | sed 's/^[^:]*: *//' | tr -d '"'"'"
}

# =============================================================================
# Runtime Detection
# =============================================================================

# Check if Podman is available
has_podman() {
    command -v podman &>/dev/null && podman info &>/dev/null
}

# Check if Docker is available
has_docker() {
    command -v docker &>/dev/null && docker info &>/dev/null
}

# Check if Docker is running in rootless mode
is_docker_rootless() {
    docker info 2>/dev/null | grep -q "rootless"
}

# Detect and select the best available container runtime
# Priority: Docker > Podman (configurable via -b flag or config file)
detect_runtime() {
    # Check for backend override (flag takes precedence over config)
    local preferred="${BACKEND_OVERRIDE:-$(load_config_value backend 2>/dev/null)}"
    preferred="${preferred:-auto}"

    # If specific backend requested, try it first
    case "$preferred" in
        docker)
            if has_docker; then
                CONTAINER_RUNTIME="docker"
                IMAGE_NAME="$IMAGE_NAME_BASE"
                if is_docker_rootless; then
                    RUNTIME_MODE="docker-rootless"
                else
                    RUNTIME_MODE="docker-rootful"
                fi
                return 0
            fi
            die "Docker requested but not available"
            ;;
        podman)
            if has_podman; then
                CONTAINER_RUNTIME="podman"
                IMAGE_NAME="localhost/${IMAGE_NAME_BASE}"
                RUNTIME_MODE="podman"
                return 0
            fi
            die "Podman requested but not available"
            ;;
    esac

    # Auto-detection: Docker first (default), then Podman
    if has_docker; then
        CONTAINER_RUNTIME="docker"
        IMAGE_NAME="$IMAGE_NAME_BASE"
        if is_docker_rootless; then
            RUNTIME_MODE="docker-rootless"
        else
            RUNTIME_MODE="docker-rootful"
        fi
        return 0
    fi

    if has_podman; then
        CONTAINER_RUNTIME="podman"
        IMAGE_NAME="localhost/${IMAGE_NAME_BASE}"
        RUNTIME_MODE="podman"
        return 0
    fi

    return 1
}

# Get runtime info for display
get_runtime_info() {
    case "$RUNTIME_MODE" in
        podman) echo "Podman" ;;
        docker-rootful) echo "Docker (rootful)" ;;
        docker-rootless) echo "Docker (rootless)" ;;
        *) echo "Unknown" ;;
    esac
}

# =============================================================================
# Helper Functions
# =============================================================================

# Check if gum is available, use nix-shell if not
gum() {
    if command -v gum &>/dev/null; then
        command gum "$@"
    else
        nix-shell -p gum --run "gum $*"
    fi
}

# Print error and exit
die() {
    gum style --foreground 1 --bold "Error: $1" >&2
    exit 1
}

# Print info message (respects QUIET)
info() {
    [[ "$QUIET" == true ]] && return
    gum style --foreground 4 "$1"
}

# Print success message (respects QUIET)
success() {
    [[ "$QUIET" == true ]] && return
    gum style --foreground 2 --bold "$1"
}

# Print warning message
warn() {
    gum style --foreground 3 "$1" >&2
}

# Generate container name from directory
generate_name() {
    local dir="$1"
    local basename
    basename=$(basename "$dir")

    # Escape: lowercase, replace non-alnum with -, collapse multiple -, trim
    local escaped
    escaped=$(echo "$basename" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/-\+/-/g' | sed 's/^-//' | sed 's/-$//')

    # Truncate to 30 chars
    escaped="${escaped:0:30}"

    # Generate 4-char hash from full path
    local hash
    hash=$(echo -n "$dir" | md5sum | cut -c1-4)

    echo "ccc-${escaped}-${hash}"
}

# Get list of managed containers
get_containers() {
    local format="${1:-table}"
    local filter="${2:-}"

    local cmd_args=(ps -a --filter "label=${LABEL_PREFIX}.managed=true")

    if [[ -n "$filter" ]]; then
        cmd_args+=(--filter "name=$filter")
    fi

    if [[ "$format" == "quiet" ]]; then
        cmd_args+=(--format '{{.Names}}')
    elif [[ "$format" == "json" ]]; then
        cmd_args+=(--format 'json')
    else
        # Simple format that works for both Podman and Docker
        # Note: Label indexing differs between runtimes and can fail when keys don't exist
        cmd_args+=(--format 'table {{.Names}}\t{{.Status}}\t{{.CreatedAt}}')
    fi

    $CONTAINER_RUNTIME "${cmd_args[@]}" 2>/dev/null
}

# Get running containers only
get_running_containers() {
    $CONTAINER_RUNTIME ps --filter "label=${LABEL_PREFIX}.managed=true" --format '{{.Names}}' 2>/dev/null
}

# Check if container exists
container_exists() {
    local name="$1"
    $CONTAINER_RUNTIME ps -a --filter "name=^${name}$" --format '{{.Names}}' 2>/dev/null | grep -q "^${name}$"
}

# Check if container is running
container_running() {
    local name="$1"
    $CONTAINER_RUNTIME ps --filter "name=^${name}$" --format '{{.Names}}' 2>/dev/null | grep -q "^${name}$"
}

# Get stopped containers only
get_stopped_containers() {
    $CONTAINER_RUNTIME ps -a --filter "label=${LABEL_PREFIX}.managed=true" --filter "status=exited" --format '{{.Names}}' 2>/dev/null
}

# Check other backend for containers and show hint if found
# Usage: hint_other_backend "list" or hint_other_backend "attach"
hint_other_backend() {
    # Check if hints are disabled in config
    local hints_enabled
    hints_enabled=$(load_config_value hints 2>/dev/null)
    [[ "$hints_enabled" == "false" ]] && return

    local cmd="${1:-}"
    local other_backend=""
    local other_count=0

    # Determine the other backend
    case "$CONTAINER_RUNTIME" in
        docker)
            if has_podman; then
                other_backend="podman"
                other_count=$(podman ps -a --filter "label=${LABEL_PREFIX}.managed=true" --format '{{.Names}}' 2>/dev/null | wc -l)
            fi
            ;;
        podman)
            if has_docker; then
                other_backend="docker"
                other_count=$(docker ps -a --filter "label=${LABEL_PREFIX}.managed=true" --format '{{.Names}}' 2>/dev/null | wc -l)
            fi
            ;;
    esac

    # Show hint if other backend has containers
    if [[ -n "$other_backend" ]] && [[ "$other_count" -gt 0 ]]; then
        echo ""
        gum style --foreground 3 "Hint: Found $other_count container(s) in $other_backend"
        if [[ -n "$cmd" ]]; then
            gum style --foreground 8 "  Try: ccc -b $other_backend $cmd"
        fi
    fi
}

# =============================================================================
# Commands
# =============================================================================

cmd_new() {
    local directory=""
    local tmux_mount=false
    local name=""
    local interactive=false
    local prompt=""
    local prompt_file=""
    local godmode=false
    local cc_args=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -d|--directory)
                directory="$2"
                shift 2
                ;;
            -t|--tmux-mount)
                tmux_mount=true
                shift
                ;;
            -n|--name)
                name="$2"
                shift 2
                ;;
            -i|--interactive)
                interactive=true
                shift
                ;;
            -p)
                if [[ "$2" == "-" ]]; then
                    prompt=$(cat)
                else
                    prompt="$2"
                fi
                shift 2
                ;;
            -f)
                prompt_file="$2"
                shift 2
                ;;
            -g|--godmode)
                godmode=true
                shift
                ;;
            --cc-args)
                cc_args="$2"
                shift 2
                ;;
            -*)
                # Handle combined short flags like -ig, -gi, -igt, etc.
                local flags="${1#-}"
                shift
                while [[ -n "$flags" ]]; do
                    local flag="${flags:0:1}"
                    flags="${flags:1}"
                    case "$flag" in
                        i) interactive=true ;;
                        g) godmode=true ;;
                        t) tmux_mount=true ;;
                        *) die "Unknown flag: -$flag" ;;
                    esac
                done
                ;;
            *)
                die "Unknown option: $1"
                ;;
        esac
    done

    # Default directory to pwd
    directory="${directory:-$(pwd)}"
    directory=$(realpath "$directory")

    # Generate name if not provided
    if [[ -z "$name" ]]; then
        name=$(generate_name "$directory")
    fi

    # Check if container already exists
    if container_exists "$name"; then
        die "Container '$name' already exists. Use 'ccc stop -n $name' first or choose a different name."
    fi

    info "Creating container: $name"
    info "Directory: $directory"
    info "Runtime: $(get_runtime_info)"

    # Generate session ID for resumable sessions
    local session_id
    session_id=$(uuidgen)

    # Build container run command
    local run_args=(
        run
        --name "$name"
        --hostname "claude-sandbox"
        -w "$directory"
        -e "CLAUDE_HOST_PATH=$directory"
        -e "CLAUDE_HOST_HOME=$HOME"
        -e "TERM=${TERM:-xterm-256color}"
        -v "$directory:$directory"
        -v "$HOME/.claude:$HOME/.claude"
        -v "$HOME/.claude.json:$HOME/.claude.json"
        --network host
        --label "${LABEL_PREFIX}.managed=true"
        --label "${LABEL_PREFIX}.name=$name"
        --label "${LABEL_PREFIX}.directory=$directory"
        --label "${LABEL_PREFIX}.runtime=$RUNTIME_MODE"
        --label "${LABEL_PREFIX}.session-id=$session_id"
    )

    # Runtime-specific configuration
    # fakeroot in entrypoint handles godmode for all runtimes
    case "$RUNTIME_MODE" in
        docker-rootful)
            # Docker rootful: use --userns=host for proper UID mapping
            run_args+=(--userns=host)
            ;;
    esac

    # Add tmux socket mount if requested
    if [[ "$tmux_mount" == true ]]; then
        local tmux_socket="/tmp/tmux-$(id -u)"
        run_args+=(-v "$tmux_socket:$tmux_socket:rw")
        info "Tmux socket mounted"
    fi

    # Build claude command args
    local claude_args=(--session-id "$session_id")

    # Add godmode flags (fakeroot makes this work on all runtimes)
    if [[ "$godmode" == true ]]; then
        run_args+=(--label "${LABEL_PREFIX}.godmode=true")
        claude_args+=(--dangerously-skip-permissions)
        info "Godmode enabled"
    fi

    # Add custom cc_args
    if [[ -n "$cc_args" ]]; then
        # shellcheck disable=SC2206
        claude_args+=($cc_args)
    fi

    # Handle prompt
    if [[ -n "$prompt" ]]; then
        # Create temp file for prompt
        local prompt_tmp
        prompt_tmp=$(mktemp)
        echo "$prompt" > "$prompt_tmp"
        run_args+=(-v "$prompt_tmp:/tmp/claude-prompt.md:ro")
        claude_args+=(-p "$(cat "$prompt_tmp")")
    elif [[ -n "$prompt_file" ]]; then
        if [[ ! -f "$prompt_file" ]]; then
            die "Prompt file not found: $prompt_file"
        fi
        run_args+=(-v "$(realpath "$prompt_file"):/tmp/claude-prompt.md:ro")
        claude_args+=(-p "$(cat "$prompt_file")")
    fi

    # Enable internal tmux mode
    run_args+=(-e "CCC_USE_TMUX=true")
    run_args+=(--label "${LABEL_PREFIX}.mode=tmux")

    # Always run detached first, then attach if interactive
    run_args+=(-d)

    # Start container with tmux + claude
    local container_id
    if [[ "$QUIET" == true ]]; then
        container_id=$($CONTAINER_RUNTIME "${run_args[@]}" "$IMAGE_NAME" claude "${claude_args[@]}" 2>/dev/null)
    else
        container_id=$(gum spin --spinner dot --title "Starting container..." -- \
            $CONTAINER_RUNTIME "${run_args[@]}" "$IMAGE_NAME" claude "${claude_args[@]}")
    fi

    # Wait for tmux socket to be ready
    sleep 0.5

    if [[ "$interactive" == true ]]; then
        # Attach to the tmux session
        info "Attaching to session (detach with Ctrl+], d)"
        info "Session ID: $session_id"
        $CONTAINER_RUNTIME exec -it "$name" /usr/bin/tmux.real -S /tmp/ccc.sock attach-session -t main
    else
        success "Container started: $name"
        info "Session ID: $session_id"
        info "Attach with: ccc attach -n $name"

        if [[ "$QUIET" == true ]]; then
            echo "$name"
        fi
    fi
}

cmd_list() {
    local quiet=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -q|--quiet)
                quiet=true
                shift
                ;;
            *)
                die "Unknown option: $1"
                ;;
        esac
    done

    if [[ "$quiet" == true ]] || [[ "$QUIET" == true ]]; then
        get_containers "quiet"
    else
        gum style --bold --foreground 5 "Claude Code Containers"
        echo ""

        local containers
        containers=$(get_containers "table")

        if [[ -z "$containers" ]] || [[ "$containers" == "NAMES"* && $(echo "$containers" | wc -l) -eq 1 ]]; then
            info "No containers found"
            hint_other_backend "list"
        else
            # ANSI color codes
            local R=$'\e[0m'        # Reset
            local B=$'\e[1m'        # Bold
            local DIM=$'\e[2m'      # Dim
            local GRN=$'\e[32m'
            local MAG=$'\e[35m'
            local CYN=$'\e[36m'     # Cyan
            local GRY=$'\e[90m'     # Dark gray

            # Print colored header
            echo -e "${B}${MAG}$(echo "$containers" | head -1)${R}"

            # Print data rows with status coloring
            echo "$containers" | tail -n +2 | while IFS= read -r line; do
                if [[ "$line" == *"Up "* ]]; then
                    # Running: green
                    echo -e "${GRN}${line}${R}"
                elif [[ "$line" == *"Created"* ]]; then
                    # Created but never started: cyan
                    echo -e "${CYN}${line}${R}"
                elif [[ "$line" == *"Exited"* ]]; then
                    # Stopped: dim gray
                    echo -e "${DIM}${GRY}${line}${R}"
                else
                    echo "$line"
                fi
            done
        fi
    fi
}

cmd_stop() {
    local name=""
    local all=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -n|--name)
                name="$2"
                shift 2
                ;;
            -a|--all)
                all=true
                shift
                ;;
            *)
                die "Unknown option: $1"
                ;;
        esac
    done

    if [[ "$all" == true ]]; then
        local containers
        containers=$(get_containers "quiet")

        if [[ -z "$containers" ]]; then
            info "No containers to stop"
            hint_other_backend "stop -a"
            return 0
        fi

        echo "Containers to stop:"
        echo "$containers" | gum style --foreground 3
        echo ""

        if gum confirm "Stop all containers?"; then
            echo "$containers" | while read -r container; do
                if [[ -n "$container" ]]; then
                    gum spin --spinner dot --title "Stopping $container..." -- \
                        $CONTAINER_RUNTIME stop "$container" >/dev/null 2>&1
                    $CONTAINER_RUNTIME rm "$container" >/dev/null 2>&1 || true
                    success "Stopped: $container"
                fi
            done
        else
            info "Cancelled"
        fi
    elif [[ -n "$name" ]]; then
        if ! container_exists "$name"; then
            die "Container not found: $name"
        fi

        gum spin --spinner dot --title "Stopping $name..." -- \
            $CONTAINER_RUNTIME stop "$name" >/dev/null 2>&1
        $CONTAINER_RUNTIME rm "$name" >/dev/null 2>&1 || true
        success "Stopped: $name"
    else
        # Interactive selection
        local containers
        containers=$(get_containers "quiet")

        if [[ -z "$containers" ]]; then
            info "No containers to stop"
            hint_other_backend "stop"
            return 0
        fi

        name=$(echo "$containers" | gum choose --header "Select container to stop:")

        if [[ -n "$name" ]]; then
            gum spin --spinner dot --title "Stopping $name..." -- \
                $CONTAINER_RUNTIME stop "$name" >/dev/null 2>&1
            $CONTAINER_RUNTIME rm "$name" >/dev/null 2>&1 || true
            success "Stopped: $name"
        fi
    fi
}

cmd_prune() {
    local containers
    containers=$(get_stopped_containers)

    if [[ -z "$containers" ]]; then
        info "No stopped containers to prune"
        hint_other_backend "prune"
        return 0
    fi

    local count
    count=$(echo "$containers" | wc -l)

    echo "Containers to remove:"
    echo "$containers" | gum style --foreground 3
    echo ""

    if gum confirm "Remove $count stopped container(s)?"; then
        echo "$containers" | while read -r container; do
            if [[ -n "$container" ]]; then
                $CONTAINER_RUNTIME rm "$container" >/dev/null 2>&1
                success "Removed: $container"
            fi
        done
    else
        info "Cancelled"
    fi
}

cmd_start() {
    local name=""
    local attach=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -n|--name)
                name="$2"
                shift 2
                ;;
            -a|--attach)
                attach=true
                shift
                ;;
            *)
                die "Unknown option: $1"
                ;;
        esac
    done

    if [[ -z "$name" ]]; then
        # Interactive selection from stopped containers
        local containers
        containers=$(get_stopped_containers)

        if [[ -z "$containers" ]]; then
            info "No stopped containers to start"
            hint_other_backend "start"
            return 0
        fi

        name=$(echo "$containers" | gum choose --header "Select container to start:")

        if [[ -z "$name" ]]; then
            die "No container selected"
        fi
    fi

    if ! container_exists "$name"; then
        die "Container not found: $name"
    fi

    if container_running "$name"; then
        info "Container already running: $name"
    else
        gum spin --spinner dot --title "Starting $name..." -- \
            $CONTAINER_RUNTIME start "$name" >/dev/null 2>&1
        success "Started: $name"
    fi

    # Get session info for display
    local session_id
    session_id=$($CONTAINER_RUNTIME inspect "$name" --format '{{index .Config.Labels "ccc.session-id"}}' 2>/dev/null)
    if [[ -n "$session_id" ]]; then
        info "Session ID: $session_id"
    fi

    if [[ "$attach" == true ]]; then
        cmd_attach -n "$name"
    else
        info "Attach with: ccc attach -n $name"
    fi
}

cmd_attach() {
    local name=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -n|--name)
                name="$2"
                shift 2
                ;;
            *)
                die "Unknown option: $1"
                ;;
        esac
    done

    if [[ -z "$name" ]]; then
        # Interactive selection
        local containers
        containers=$(get_running_containers)

        if [[ -z "$containers" ]]; then
            info "No running containers to attach to"
            hint_other_backend "attach"
            return 0
        fi

        name=$(echo "$containers" | gum choose --header "Select container to attach:")

        if [[ -z "$name" ]]; then
            die "No container selected"
        fi
    fi

    # Start container if it's stopped
    if ! container_running "$name"; then
        if container_exists "$name"; then
            info "Starting stopped container: $name"
            $CONTAINER_RUNTIME start "$name" >/dev/null 2>&1
            sleep 1  # Give it a moment to start
        else
            die "Container '$name' not found"
        fi
    fi

    # Check container mode
    local mode
    mode=$($CONTAINER_RUNTIME inspect "$name" --format '{{index .Config.Labels "ccc.mode"}}' 2>/dev/null)

    if [[ "$mode" != "tmux" ]]; then
        die "Container '$name' is not in tmux mode. Use 'ccc exec -n $name --shell' for shell access."
    fi

    # Get session ID for display
    local session_id
    session_id=$($CONTAINER_RUNTIME inspect "$name" --format '{{index .Config.Labels "ccc.session-id"}}' 2>/dev/null)
    if [[ -n "$session_id" ]]; then
        info "Session ID: $session_id"
    fi

    # Attach to the tmux session
    info "Attaching to session (detach with Ctrl+], d)"
    $CONTAINER_RUNTIME exec -it "$name" /usr/bin/tmux.real -S /tmp/ccc.sock attach-session -t main
}

cmd_logs() {
    local name=""
    local follow=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -n|--name)
                name="$2"
                shift 2
                ;;
            -f|--follow)
                follow=true
                shift
                ;;
            *)
                die "Unknown option: $1"
                ;;
        esac
    done

    if [[ -z "$name" ]]; then
        # Interactive selection
        local containers
        containers=$(get_containers "quiet")

        if [[ -z "$containers" ]]; then
            info "No containers found"
            hint_other_backend "logs"
            return 0
        fi

        name=$(echo "$containers" | gum choose --header "Select container:")

        if [[ -z "$name" ]]; then
            die "No container selected"
        fi
    fi

    if ! container_exists "$name"; then
        die "Container not found: $name"
    fi

    # Check container mode
    local mode
    mode=$($CONTAINER_RUNTIME inspect "$name" --format '{{index .Config.Labels "ccc.mode"}}' 2>/dev/null)

    # For tmux mode running containers, use tmux capture
    if [[ "$mode" == "tmux" ]] && container_running "$name"; then
        # Capture tmux pane content (scrollback)
        $CONTAINER_RUNTIME exec "$name" /usr/bin/tmux.real -S /tmp/ccc.sock capture-pane -t main -p -S -1000
        if [[ "$follow" == true ]]; then
            info "Use 'ccc attach' to see live output"
        fi
    else
        # Standard container logs for non-tmux or stopped containers
        local log_args=(logs)
        if [[ "$follow" == true ]]; then
            log_args+=(-f)
        fi
        log_args+=("$name")
        $CONTAINER_RUNTIME "${log_args[@]}"
    fi
}

cmd_exec() {
    local name=""
    local shell_mode=false
    local cmd_args=()

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -n|--name)
                name="$2"
                shift 2
                ;;
            --shell)
                shell_mode=true
                shift
                ;;
            --)
                shift
                cmd_args=("$@")
                break
                ;;
            *)
                # Everything else is the command
                cmd_args=("$@")
                break
                ;;
        esac
    done

    if [[ -z "$name" ]]; then
        # Interactive selection
        local containers
        containers=$(get_running_containers)

        if [[ -z "$containers" ]]; then
            info "No running containers"
            hint_other_backend "exec"
            return 0
        fi

        name=$(echo "$containers" | gum choose --header "Select container:")

        if [[ -z "$name" ]]; then
            die "No container selected"
        fi
    fi

    if ! container_running "$name"; then
        die "Container '$name' is not running"
    fi

    # Check container mode
    local mode
    mode=$($CONTAINER_RUNTIME inspect "$name" --format '{{index .Config.Labels "ccc.mode"}}' 2>/dev/null)

    if [[ "$shell_mode" == true ]] || [[ ${#cmd_args[@]} -eq 0 ]]; then
        # Shell mode: run command directly in container
        if [[ ${#cmd_args[@]} -eq 0 ]]; then
            cmd_args=(sh)
        fi
        $CONTAINER_RUNTIME exec -it -e "HOME=$HOME" "$name" "${cmd_args[@]}"
    elif [[ "$mode" == "tmux" ]]; then
        # Send command to claude TUI via tmux send-keys
        local cmd_string="${cmd_args[*]}"
        $CONTAINER_RUNTIME exec "$name" /usr/bin/tmux.real -S /tmp/ccc.sock send-keys -t main "$cmd_string" Enter
        info "Sent to TUI: $cmd_string"
    else
        # Non-tmux container - can only run shell commands
        warn "Container not in tmux mode - running command in shell"
        $CONTAINER_RUNTIME exec -it -e "HOME=$HOME" "$name" "${cmd_args[@]}"
    fi
}

cmd_config() {
    local config_file
    config_file=$(get_config_file)
    local config_dir
    config_dir=$(dirname "$config_file")

    # Create config dir and file if they don't exist
    if [[ ! -f "$config_file" ]]; then
        mkdir -p "$config_dir"
        # Copy example config if available
        if [[ -f "${SCRIPT_DIR}/example_config/config.yaml" ]]; then
            cp "${SCRIPT_DIR}/example_config/config.yaml" "$config_file"
            info "Created config file from example"
        else
            # Create minimal config
            cat > "$config_file" << 'EOF'
# ccc configuration
backend: auto
hints: true
EOF
            info "Created new config file"
        fi
    fi

    # Open in editor
    local editor="${EDITOR:-${VISUAL:-vi}}"
    "$editor" "$config_file"
}

cmd_help() {
    gum style --bold --foreground 5 --border double --padding "0 2" \
        "ccc - Claude Code Container CLI"

    echo ""
    gum style --bold "Usage:"
    echo "  ccc <command> [options]"
    echo ""

    gum style --bold "Commands:"
    gum format -- \
        "  **new**      Start a new container" \
        "  **list**     List managed containers (alias: ls)" \
        "  **start**    Start a stopped container" \
        "  **stop**     Stop containers" \
        "  **prune**    Remove all stopped containers" \
        "  **attach**   Attach to a running container" \
        "  **logs**     View container logs" \
        "  **exec**     Send command to TUI or run in shell" \
        "  **config**   Edit configuration file" \
        "  **help**     Show this help"

    echo ""
    gum style --bold "ccc new options:"
    gum format -- \
        "  **-d, --directory** <path>  Mount directory (default: pwd)" \
        "  **-t, --tmux-mount**        Mount tmux socket" \
        "  **-n, --name** <name>       Container name (auto-generated if omitted)" \
        "  **-i, --interactive**       Attach immediately" \
        "  **-p** <prompt|->           System prompt (- for stdin)" \
        "  **-f** <file>               System prompt from file" \
        "  **-g, --godmode**           Full permissions (--dangerously-skip-permissions)" \
        "  **--cc-args** <args>        Additional claude arguments"

    echo ""
    gum style --bold "ccc start options:"
    gum format -- \
        "  **-n, --name** <name>   Container name" \
        "  **-a, --attach**        Attach after starting"

    echo ""
    gum style --bold "ccc exec options:"
    gum format -- \
        "  **-n, --name** <name>   Container name" \
        "  **--shell**             Run command in container shell (not TUI)" \
        "  **command**             Command to send to TUI (default)" \
        "  **(no args)**           Opens interactive shell (--shell implied)"

    echo ""
    gum style --bold "Global options:"
    gum format -- \
        "  **-b, --backend** <name>  Container backend (docker, podman, auto)" \
        "  **-q, --quiet**           Suppress verbose output" \
        "  **-h, --help**            Show help"

    echo ""
    gum style --bold "Examples:"
    gum style --foreground 8 "  # Start interactive godmode session in current directory"
    echo "  ccc new -ig"
    echo ""
    gum style --foreground 8 "  # Start headless container with custom prompt"
    echo "  ccc new -p 'Build and test the project'"
    echo ""
    gum style --foreground 8 "  # List all containers"
    echo "  ccc list"
    echo ""
    gum style --foreground 8 "  # Attach to a running container"
    echo "  ccc attach"
    echo ""
    gum style --foreground 8 "  # Restart a stopped container and attach"
    echo "  ccc start -a"
    echo ""
    gum style --foreground 8 "  # Send a command to Claude TUI"
    echo "  ccc exec -n mycontainer 'help me debug this'"
    echo ""
    gum style --foreground 8 "  # Run a shell command inside the container"
    echo "  ccc exec -n mycontainer --shell ls -la"
}

# =============================================================================
# Main
# =============================================================================

main() {
    # Parse global flags
    local args=()
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -q|--quiet)
                QUIET=true
                shift
                ;;
            -b|--backend)
                BACKEND_OVERRIDE="$2"
                shift 2
                ;;
            -h|--help)
                cmd_help
                exit 0
                ;;
            *)
                args+=("$1")
                shift
                ;;
        esac
    done

    # Restore positional args
    set -- "${args[@]}"

    # Detect container runtime
    if ! detect_runtime; then
        die "No container runtime found. Please install Podman or Docker."
    fi

    # Check for command
    if [[ $# -eq 0 ]]; then
        cmd_help
        exit 0
    fi

    local command="$1"
    shift

    case "$command" in
        new)
            cmd_new "$@"
            ;;
        list|ls)
            cmd_list "$@"
            ;;
        start)
            cmd_start "$@"
            ;;
        stop)
            cmd_stop "$@"
            ;;
        prune)
            cmd_prune "$@"
            ;;
        attach)
            cmd_attach "$@"
            ;;
        logs)
            cmd_logs "$@"
            ;;
        exec)
            cmd_exec "$@"
            ;;
        config)
            cmd_config "$@"
            ;;
        help)
            cmd_help
            ;;
        *)
            die "Unknown command: $command. Run 'ccc help' for usage."
            ;;
    esac
}

main "$@"
